#include <stdbool.h>
#include "gpio.h"
// #include "debug_serial.h"
// #include "i2c_tx.h"

// TODO: Може зробимо так? : https://github.com/wagiminator/Development-Boards/tree/main/CH32V003A4M6_DevBoard/software/oled_dma
// #include "oled_min.h"
#include "oled_dma.h"
// #include "oled_term.h"
#include "system.h"

/*
    PIN MAP
    -------

    pin2 - VSS
    pin4 - VDD

    pin8 - DIO (programming), PD5 - UART TX (debug)

    pin1 - PA1 - Temporary LED

    OLED-display
    pin5 - PC1 - I2C SDA
    pin6 - PC2 - I2C SCL

*/

#define PIN_LED    PA1   // pin connected to LED (Temporary)

#if 1
#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)
#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)
/*
 * initialize adc for polling
 */
void adc_init( void )
{
	// ADCCLK = 24 MHz => RCC_ADCPRE = 0: divide by 2
	RCC->CFGR0 &= ~(0x1F<<11);
	
	// Enable GPIOD and ADC
	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_ADC1;
	
	// PD4 is analog input chl 7
	GPIOD->CFGLR &= ~(0xf<<(4*4));	// CNF = 00: Analog, MODE = 00: Input
	
	// Reset the ADC to init all regs
	RCC->APB2PRSTR |= RCC_APB2Periph_ADC1;
	RCC->APB2PRSTR &= ~RCC_APB2Periph_ADC1;
	
	// Set up single conversion on chl 7
	ADC1->RSQR1 = 0;
	ADC1->RSQR2 = 0;
	ADC1->RSQR3 = 7;	// 0-9 for 8 ext inputs and two internals
	
	// set sampling time for chl 7
	ADC1->SAMPTR2 &= ~(ADC_SMP0<<(3*7));
	ADC1->SAMPTR2 |= 7<<(3*7);	// 0:7 => 3/9/15/30/43/57/73/241 cycles
		
	// turn on ADC and set rule group to sw trig
	ADC1->CTLR2 |= ADC_ADON | ADC_EXTSEL;
	
	// Reset calibration
	ADC1->CTLR2 |= ADC_RSTCAL;
	while(ADC1->CTLR2 & ADC_RSTCAL);
	
	// Calibrate
	ADC1->CTLR2 |= ADC_CAL;
	while(ADC1->CTLR2 & ADC_CAL);
	
	// should be ready for SW conversion now
}
#endif

static inline void init(void)
{
    PIN_output(PIN_LED);
    // PIN_high(PIN_LED);
    PIN_low(PIN_LED);

    // SYS_init();
    // UART_init();

//   ADC_init();
//   ADC_input(PIN_PAD);

    // DEBUG_init();

    OLED_init();
    ADC_init();                       // init ADC
    // adc_init();
}

#if 0
volatile unsigned int counter = 0;
volatile uint32_t last_value = 0;

void EXTI7_0_IRQHandler( void ) __attribute__((interrupt));
void EXTI7_0_IRQHandler( void ) 
{
    static uint32_t starttime;

    PIN_high(PC1);
    unsigned pin = PIN_read(PD6);

    if(pin != 0) {
        starttime = STK->CNT;
    } else {
        last_value = STK->CNT - starttime;
    }
	EXTI->INTFR = EXTI_INTF_INTF6;
    PIN_low(PC1);
}
#endif

#include "spritebank.h"

#if 0
// OLED commands
#define JOY_OLED_init             OLED_init
#define JOY_OLED_end              I2C_stop
#define JOY_OLED_send(b)          I2C_write(b)
#define JOY_OLED_send_command(c)  OLED_send_command(c)
#define JOY_OLED_data_start(y)    {OLED_setpos(0,y);OLED_data_start();}
#define JOY_OLED_data_startX(x,y)    {OLED_setpos(x,y);OLED_data_start();}

// Steeled from here: https://github.com/lynniemagoo/oled-font-pack/blob/master/fonts/16x16/arial-bold-font-16x16.js

// const uint16_t numbers[16*10] = {
//     0x0000,0x0000,0x0000,0x0000,0x0ff0,0x1ff8,0x381c,0x300c,0x300c,0x381c,0x1ff8,0x0ff0,0x0000,0x0000,0x0000,0x0000,  // 0
//     0x0000,0x0000,0x0000,0x0000,0x0060,0x0030,0x0018,0x3ffc,0x3ffc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 1
//     0x0000,0x0000,0x0000,0x0000,0x3030,0x3838,0x3c1c,0x360c,0x370c,0x338c,0x31f8,0x3070,0x0000,0x0000,0x0000,0x0000,  // 2
//     0x0000,0x0000,0x0000,0x0000,0x0c10,0x1c18,0x381c,0x30cc,0x30cc,0x39cc,0x1ffc,0x0f38,0x0000,0x0000,0x0000,0x0000,  // 3
//     0x0000,0x0000,0x0000,0x0000,0x0e00,0x0f00,0x0dc0,0x0ce0,0x0c38,0x3ffc,0x3ffc,0x0c00,0x0000,0x0000,0x0000,0x0000,  // 4
//     0x0000,0x0000,0x0000,0x0000,0x0de0,0x1dfc,0x38dc,0x30cc,0x30cc,0x39cc,0x1f8c,0x0f00,0x0000,0x0000,0x0000,0x0000,  // 5
//     0x0000,0x0000,0x0000,0x0000,0x07e0,0x1ff8,0x399c,0x30cc,0x30cc,0x31cc,0x1f9c,0x0f18,0x0000,0x0000,0x0000,0x0000,  // 6
//     0x0000,0x0000,0x0000,0x0000,0x000c,0x000c,0x3c0c,0x3f8c,0x07ec,0x007c,0x001c,0x000c,0x0000,0x0000,0x0000,0x0000,  // 7
//     0x0000,0x0000,0x0000,0x0000,0x0e70,0x1ff8,0x318c,0x318c,0x318c,0x318c,0x1ff8,0x0e70,0x0000,0x0000,0x0000,0x0000,  // 8
//     0x0000,0x0000,0x0000,0x0000,0x18f0,0x39f8,0x338c,0x330c,0x330c,0x399c,0x1ff8,0x07e0,0x0000,0x0000,0x0000,0x0000,  // 9    
// };

#include "sinclair-m-i-font-16x16.h"

static const uint8_t p0[] = { 0xf8, 0x1f, 0xfc, 0x3f, 0xe, 0x70, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0xe, 0x70, 0xfc, 0x3f, 0xf8, 0x1f };

const uint8_t numbers[] = {
    0xf8, 0x1f, 0x0, 0x2, 0xf8, 0x1f, 0xf8, 0x1f, 0x0, 0x1f, 0xfe, 0x7f, 0xf8, 0x1f, 0xfe, 0x7f,
    0xf8, 0x1f, 0xf8, 0x1f, 0xfc, 0x3f, 0x0, 0x3, 0xfc, 0x3f, 0xfc, 0x3f, 0x80, 0x1f, 0xfe, 0x7f,
    0xfc, 0x3f, 0xfe, 0x7f, 0xfc, 0x3f, 0xfc, 0x3f, 0x1e, 0x78, 0x80, 0x3, 0xe, 0x78, 0x1e, 0x78,
    0xc0, 0x1d, 0xe, 0x40, 0x1e, 0x78, 0xe, 0x70, 0x1e, 0x78, 0x1e, 0x78, 0xe, 0x70, 0xc0, 0x3, 
    0xe, 0x70, 0xe, 0x70, 0xe0, 0x1c, 0xe, 0x0, 0xe, 0x0, 0x0, 0x70, 0xe, 0x70, 0xe, 0x70, 0xe, 
    0x70, 0xe0, 0x3, 0x0, 0x70, 0x0, 0x70, 0x70, 0x1c, 0xe, 0x0, 0xe, 0x0, 0x0, 0x38, 0xe, 0x70,
    0xe, 0x70, 0xe, 0x70, 0xf0, 0x3, 0x0, 0x70, 0x0, 0x70, 0x38, 0x1c, 0xfe, 0x1f, 0xe, 0x0, 
    0x0, 0x1c, 0x1e, 0x78, 0xe, 0x70, 0xe, 0x70, 0x80, 0x3, 0x0, 0x70, 0x0, 0x3c, 0x1c, 0x1c,
    0xfe, 0x3f, 0xfe, 0x3f, 0x0, 0xe, 0xfc, 0x3f, 0xe, 0x70, 0xe, 0x70, 0x80, 0x3, 0x0, 0x70,
    0x0, 0x1f, 0xe, 0x1c, 0x0, 0x78, 0xfe, 0x7f, 0x0, 0x7, 0xf8, 0x1f, 0x1e, 0x70, 0xe, 0x70,
    0x80, 0x3, 0x0, 0x78, 0x0, 0x1f, 0xfe, 0x7f, 0x0, 0x70, 0x1e, 0x78, 0x80, 0x3, 0x1c, 0x38,
    0xfc, 0x7f, 0xe, 0x70, 0x80, 0x3, 0x0, 0x3c, 0x0, 0x3c, 0xfe, 0x7f, 0x0, 0x70, 0xe, 0x70,
    0xc0, 0x1, 0xe, 0x70, 0xf8, 0x7f, 0xe, 0x70, 0x80, 0x3, 0x0, 0xf, 0x0, 0x78, 0x0, 0x1c, 
    0x0, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 0x0, 0x70, 0xe, 0x70, 0x80, 0x3, 0xc0, 0x3, 
    0x0, 0x70, 0x0, 0x1c, 0x0, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 0x0, 0x70, 0xe, 0x70, 
    0x80, 0x3, 0xf0, 0x0, 0xe, 0x70, 0x0, 0x1c, 0xe, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 
    0x0, 0x70, 0x1e, 0x78, 0x80, 0x3, 0x3c, 0x0, 0x1e, 0x78, 0x0, 0x1c, 0x1e, 0x78, 0x1e, 0x78,
    0xc0, 0x1, 0x1e, 0x78, 0x1e, 0x78, 0xfc, 0x3f, 0x80, 0x3, 0xfe, 0x7f, 0xfc, 0x3f, 0x0, 0x1c,
    0xfc, 0x3f, 0xfc, 0x3f, 0xc0, 0x1, 0xfc, 0x3f, 0xfc, 0x3f, 0xf8, 0x1f, 0xe0, 0xf, 0xfe, 0x7f,
    0xf8, 0x1f, 0x0, 0x7e, 0xf8, 0x1f, 0xf8, 0x1f, 0xc0, 0x1, 0xf8, 0x1f, 0xf8, 0x1f };

const uint8_t heartImage[8] =
{
    0B00001110,
    0B00011111,
    0B00111111,
    0B01111110,
    0B01111110,
    0B00111101,
    0B00011001,
    0B00001110
};

const uint32_t digits[] = {
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x0001ff00,0x000fffe0,0x003fe7f8,0x003f003c,0x0073c01e,0x00e1e00e,0x00c07006,0x00c03c07,0x00c01e06,0x00e0070e,0x0070039c,0x003c01f8,0x001ffff0,0x0007ffc0,0x00007c00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 0
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000008,0x00000018,0x00000018,0x0000000c,0x0000000c,0x0000000e,0x00fffffe,0x00fffffe,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 1
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00e00010,0x00f80038,0x00fc001c,0x00de000e,0x00c70006,0x00c38006,0x00c1c007,0x00c0e006,0x00c0700e,0x00c03c0e,0x00c01f7c,0x00c00ff8,0x00c003f0,0x00200000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 2
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00200008,0x0078001c,0x00e0000c,0x00e00006,0x00c01806,0x00c01806,0x00c01c06,0x00c01c06,0x00e03e0e,0x0070771c,0x007ff3fc,0x003fe1f0,0x000f8000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 3
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00038000,0x0003e000,0x0003f000,0x0003bc00,0x00038e00,0x00038780,0x000381e0,0x00038070,0x0003803c,0x00fffffe,0x00fffffe,0x00fffffe,0x00038000,0x00038000,0x00038000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 4
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00100000,0x00301f00,0x00781ffe,0x00e01ffe,0x00e00e06,0x00c00606,0x00c00606,0x00c00606,0x00c00606,0x00e00e06,0x00e00e06,0x00783c06,0x003ff806,0x001ff006,0x00038000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 5
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0007ffc0,0x001ffff0,0x003c38f8,0x00701c1c,0x00e00c0e,0x00c00606,0x00c00606,0x00c00607,0x00c00e06,0x00e00e06,0x00783c0e,0x003ff81c,0x001fe004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 6
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000006,0x00000006,0x00800006,0x00f00006,0x00fe0006,0x007fc006,0x000ff006,0x0001fe06,0x00003f86,0x000007f6,0x000001fe,0x0000003e,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 7
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00060000,0x003fc060,0x007fe1f8,0x0070f3fc,0x00e0370e,0x00c03e06,0x00c01c06,0x00c01c07,0x00c01c07,0x00c03e06,0x00e0770e,0x0070f3fc,0x007fe1f8,0x001f80e0,0x00020000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 8
    // 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00400ff0,0x00703ff8,0x00e03c3c,0x00c0700e,0x00c06006,0x00c0e006,0x00c06007,0x00e06006,0x0060600e,0x0078301e,0x003f187c,0x001ffff8,0x0007ffe0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 9

    // Вкрав фонт звідси: https://github.com/lynniemagoo/oled-font-pack/blob/master/fonts/24x32/ubuntu-bold-font-24x32.js
    0x00000000,0x00000000,0x00000000,0x0007fe00,0x003fffc0,0x007fffe0,0x00fffff0,0x01f801f8,0x03e0007c,0x03c0703c,0x03c0f83c,0x03c0f83c,0x03c0703c,0x03e0007c,0x01f801f8,0x01fffff8,0x00fffff0,0x007fffe0,0x001fff80,0x0001f800,0x00000000,0x00000000,0x00000000,0x00000000,  // 0
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000080,0x03c007c0,0x03c007c0,0x03c003e0,0x03c003e0,0x03c001f0,0x03fffff8,0x03fffffc,0x03fffffc,0x03fffffc,0x03fffffc,0x03c00000,0x03c00000,0x03c00000,0x03c00000,0x03c00000,0x00000000,0x00000000,0x00000000,0x00000000,  // 1
    0x00000000,0x00000000,0x00000000,0x00000020,0x03e00070,0x03f800f8,0x03fc0078,0x03fe0078,0x03ff003c,0x03df803c,0x03c7c03c,0x03c3e03c,0x03c3f03c,0x03c1f87c,0x03c0fff8,0x03c07ff8,0x03c03ff0,0x03c01fe0,0x03c007c0,0x03c00000,0x00000000,0x00000000,0x00000000,0x00000000,  // 2
    0x00000000,0x00000000,0x00000000,0x00000000,0x01c00010,0x01e00078,0x01e00078,0x03c0787c,0x03c0783c,0x03c0783c,0x03c0783c,0x03c0783c,0x03e0fc7c,0x03f1fffc,0x01fffff8,0x01ffeff8,0x00ffeff0,0x007fc3c0,0x001f0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 3
    0x00000000,0x00000000,0x00000000,0x000f8000,0x000fc000,0x000ff000,0x000ff800,0x000ffe00,0x000f3f00,0x000f1f80,0x000f07e0,0x000f03f0,0x000f00f8,0x03fffffc,0x03fffffc,0x03fffffc,0x03fffffc,0x03fffffc,0x000f0000,0x000f0000,0x000f0000,0x00000000,0x00000000,0x00000000,  // 4
    0x00000000,0x00000000,0x00000000,0x01800000,0x01e00000,0x03e03e00,0x03c03ffc,0x03c03ffc,0x03c03ffc,0x03c03ffc,0x03c07c3c,0x03c07c3c,0x03e07c3c,0x01f0f83c,0x01fff83c,0x01fff03c,0x00fff03c,0x007fe03c,0x001f8000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 5
    0x00000000,0x00000000,0x00000000,0x00000000,0x000ff000,0x007ffe00,0x00ffff80,0x01ffffc0,0x01ffffe0,0x03f07bf0,0x03c079f0,0x03c078f8,0x03c07878,0x03e0f87c,0x03fff83c,0x01fff83c,0x00fff03c,0x007fe03c,0x001f8000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 6
    0x00000000,0x00000000,0x00000000,0x00000000,0x0000003c,0x0000003c,0x0000003c,0x03c0003c,0x03fc003c,0x03ff803c,0x03ffe03c,0x03fff83c,0x003ffe3c,0x0003ffbc,0x00007ffc,0x00000ffc,0x000003fc,0x000000fc,0x0000007c,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 7
    0x00000000,0x00000000,0x00000000,0x003e0000,0x00ff8fe0,0x00ffdff0,0x01ffdff8,0x01e1fff8,0x03e0fc7c,0x03c0783c,0x03c0783c,0x03c0f03c,0x03c0f03c,0x03c0f83c,0x03e1fc7c,0x01e3fff8,0x01ffdff8,0x00ff8ff0,0x007f03c0,0x003e0000,0x00000000,0x00000000,0x00000000,0x00000000,  // 8
    0x00000000,0x00000000,0x00000000,0x00000000,0x00001f80,0x03c07fe0,0x03c0fff0,0x03c0fff8,0x03c1fff8,0x03e1f07c,0x01e1e03c,0x01e1e03c,0x00f1e03c,0x00f9e07c,0x007de0f8,0x003ffff8,0x001ffff0,0x000fffe0,0x0003ff80,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,  // 9
};

uint8_t voltage[4] = {0,0,0,0};


void testMem()
{
    static uint32_t _dbg_counter = 1;

    // const uint8_t buf[16] = "1234";
    for(int y = 0; y < 4; y++) {
        JOY_OLED_data_startX(14, y);
        for(int c = 0; c < 4; c++) {
            uint8_t digit = voltage[c];
            for(int x = 0; x < 24; x++) {
                if(y==3) {
                    JOY_OLED_send((digits[digit*24 + x] >> 24) & 0xFF);
                } else if(y==2) {
                    JOY_OLED_send((digits[digit*24 + x] >> 16) & 0xFF);
                } else if(y==1) {
                    JOY_OLED_send((digits[digit*24 + x] >> 8) & 0xFF);
                } else {
                    JOY_OLED_send(digits[digit*24 + x] & 0xFF);
                }
                // JOY_OLED_send(digits[digit*16 + x] & 0xFF);
            }
            if(c==0) {
                JOY_OLED_send(0x00);
                if(y==3) {
                    JOY_OLED_send(0x03);  JOY_OLED_send(0x03); JOY_OLED_send(0x03);
                } else if(y==2) {
                    JOY_OLED_send(0x80);  JOY_OLED_send(0x80); JOY_OLED_send(0x80);
                } else {
                    JOY_OLED_send(0x0); JOY_OLED_send(0x0); JOY_OLED_send(0x00);
                }
                JOY_OLED_send(0x00);
            }
        }
        JOY_OLED_send(0x00);
        if(y==0) {
            JOY_OLED_send(_dbg_counter & 0xFF);
        } else if(y==1) {
            JOY_OLED_send((_dbg_counter >> 8) & 0xFF);
        } else if(y==2) {
            JOY_OLED_send((_dbg_counter >> 16) & 0xFF);
        } else {
            JOY_OLED_send((_dbg_counter >> 24) & 0xFF);
        }   
        JOY_OLED_send(0x00);
        JOY_OLED_end();
    }

        _dbg_counter <<= 1;
        if(_dbg_counter == 0) {
            _dbg_counter = 1;
        }

}

void showVoltage()
{
    // 8 символов
    char buffer[9] = "U=4.456V";
    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y);
        for(uint8_t c = 0; c < 8; c++) {
            uint8_t digit = buffer[c] - ' ';
            
            for(uint8_t x = 0; x < 16; x++) {
                if(y==1){
                    JOY_OLED_send((font[digit*16 + x] >> 8) & 0xFF);
                } else {
                    JOY_OLED_send(font[digit*16 + x] & 0xFF);
                }
                // JOY_OLED_send((numbers[digit*16 + x] >> 8) & 0xFF);
                // JOY_OLED_send(numbers[digit*16 + x] & 0xFF);
            }
        }
        // for(uint8_t x = 0; x < 128; x++) {
        //     // JOY_OLED_send((MAIN[x+(y*128)]));
        //     JOY_OLED_send(x);
        // }
        JOY_OLED_end();
    }

    // const uint8_t buf2[9]

    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y+2);
        // for(uint8_t c = 0; c < 8; c++) {
        // }
        for(uint8_t x = 0; x < 16; x++) {
            JOY_OLED_send(p0[x*2+y]);
        }

        JOY_OLED_end();
    }


    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y+4);
        for(uint8_t x = 0; x < 128; x++) {
            JOY_OLED_send(x);
        }

        JOY_OLED_end();
    }

}

#endif

static inline uint16_t _ADC_read_VDD(void) {
  ADC_input_VREF();                             // set VREF as ADC input
//   return((uint32_t)1200 * 1023 / ADC_read());   // return VDD im mV
    uint32_t x = 1200 * 1023;
    uint32_t adc = ADC_read();

    // Iterate division v = x / adc
    uint16_t v = 0;
    while(x >= adc) {
        x -= adc;
        v++;
    }
    return v;
}

int main(void)
{
    init();

    char buffer[9] = "4456v";

    OLED_clear();
    OLED_print(0, 0, "Hello World", 1, 1);
    OLED_print(0, 8, buffer, 1, 4);


    // OLED_stretchPrint(0, 12, "1234567890", 1);
    // OLED_smoothPrint(64, 12, "12345", 1);    

    for(;;) {
        buffer[3] += 1;
        if(buffer[3] > '9') {
            buffer[3] = '0';
            buffer[2] += 1;
            if(buffer[2] > '9') {
                buffer[2] = '0';
                buffer[1] += 1;
                if(buffer[1] > '9') {
                    buffer[1] = '0';
                    buffer[0] += 1;
                    if(buffer[0] > '9') {
                        buffer[0] = '0';
                    }
                }
            }
        }
        OLED_print(0, 8, buffer, 1, 4);

    }

#if 0
    // OLED_clear();

    // OLED_setline(0);
    // OLED_print("Hello, World!");
    // OLED_setline(2);
    // OLED_print("Hello, World!");

    OLED_fill(0x01);

    // showVoltage();
    // testMem();

    // uint8_t y,x; 
    // for(y = 0; y < 8; y++) {
    //     JOY_OLED_data_start(y);
    //     for(x = 0; x < 128; x++) {
    //         // JOY_OLED_send((MAIN[x+(y*128)]));
    //         JOY_OLED_send(0xFF);
    //     }
    //     JOY_OLED_end();
    // }

    // DEBUG_println("Start");


    // const uint8_t logo[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00};

    // OLED_draw_bmp(0, 0, 8, 8, logo);

    #define RX_TIMEOUT  500 * DLY_MS_TIME

    uint32_t next_tick = STK->CNT + RX_TIMEOUT;

//   while(((int32_t)(STK->CNT - end)) < 0);

    // uint8_t pattern = 0x01;

#define INTEGRATOR_SIZE 50000

    uint64_t integrator = 0;
    uint32_t counter = 0;

    while(1)
    {
        // #if defined(STARTKIT)
        //     PIN_toggle(PIN_LED);
        // #endif
        // DLY_ms(500);
        ADC_input_VREF();
        uint32_t mV = ADC_read();
        // unsigned mV = _ADC_read_VDD();
        integrator += mV;
        counter++;
        // DLY_us(100);

        if(counter >= INTEGRATOR_SIZE) {
            // mV = integrator;

            #if 1
            // Iterate division v = x / adc
            uint64_t x = (uint64_t)1200 * 1023  * INTEGRATOR_SIZE;

            uint16_t v = 0;
            while(x >= integrator) {
                x -= integrator;
                v++;
            }
            mV = v;
            #endif

            integrator = 0;
            counter = 0;

        // if(((int32_t)(STK->CNT - next_tick)) > 0) {
        //     next_tick = STK->CNT + RX_TIMEOUT;

            // PIN_toggle(PIN_LED);

            // mV
            // unsigned mV = _ADC_read_VDD();

            // ADC_input_VREF();
            // uint32_t mV = ADC_read();
            // integrator += mV;
            // counter++;
            // mV = 1234;

            if(mV > 9999) {
                voltage[0] = 8;
                voltage[1] = 8;
                voltage[2] = 8;
                voltage[3] = 8;

            } else {

                unsigned volts = 0;
                while(mV >= 1000) {
                    mV -= 1000;
                    volts++;
                }
                voltage[0] = volts;

                unsigned mV100 = 0;
                while(mV >= 100) {
                    mV -= 100;
                    mV100++;
                }
                voltage[1] = mV100;

                unsigned mV10 = 0;
                while(mV >= 10) {
                    mV -= 10;
                    mV10++;
                }
                voltage[2] = mV10;
                voltage[3] = mV;
            }
            testMem();

            // OLED_fill(pattern++);
        }

    #if 0
        counter++;
        uint32_t duration = last_value / (F_CPU / 1000000);        // Значення у мікросекундах

        DEBUG_printf("Counter: %d  Last value: %d  Duration: %d\n", counter, last_value, duration);
    #endif
    }

#endif
}
