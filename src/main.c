#include <stdbool.h>
#include "gpio.h"
#include "debug_serial.h"
#include "i2c_tx.h"
#include "oled_min.h"
// #include "oled_term.h"
#include "system.h"

/*
    PIN MAP
    -------

    pin2 - VSS
    pin4 - VDD

    pin8 - DIO (programming), PD5 - UART TX (debug)

    pin1 - PA1 - Temporary LED

    OLED-display
    pin5 - PC1 - I2C SDA
    pin6 - PC2 - I2C SCL

*/

#define PIN_LED    PA1   // pin connected to LED (Temporary)

static inline void init(void)
{
    PIN_output(PIN_LED);
    PIN_high(PIN_LED);

    // SYS_init();
    // UART_init();

//   ADC_init();
//   ADC_input(PIN_PAD);

    // DEBUG_init();

    OLED_init();
}

#if 0
volatile unsigned int counter = 0;
volatile uint32_t last_value = 0;

void EXTI7_0_IRQHandler( void ) __attribute__((interrupt));
void EXTI7_0_IRQHandler( void ) 
{
    static uint32_t starttime;

    PIN_high(PC1);
    unsigned pin = PIN_read(PD6);

    if(pin != 0) {
        starttime = STK->CNT;
    } else {
        last_value = STK->CNT - starttime;
    }
	EXTI->INTFR = EXTI_INTF_INTF6;
    PIN_low(PC1);
}
#endif

#include "spritebank.h"

// OLED commands
#define JOY_OLED_init             OLED_init
#define JOY_OLED_end              I2C_stop
#define JOY_OLED_send(b)          I2C_write(b)
#define JOY_OLED_send_command(c)  OLED_send_command(c)
#define JOY_OLED_data_start(y)    {OLED_setpos(0,y);OLED_data_start();}

// Steeled from here: https://github.com/lynniemagoo/oled-font-pack/blob/master/fonts/16x16/arial-bold-font-16x16.js

// const uint16_t numbers[16*10] = {
//     0x0000,0x0000,0x0000,0x0000,0x0ff0,0x1ff8,0x381c,0x300c,0x300c,0x381c,0x1ff8,0x0ff0,0x0000,0x0000,0x0000,0x0000,  // 0
//     0x0000,0x0000,0x0000,0x0000,0x0060,0x0030,0x0018,0x3ffc,0x3ffc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 1
//     0x0000,0x0000,0x0000,0x0000,0x3030,0x3838,0x3c1c,0x360c,0x370c,0x338c,0x31f8,0x3070,0x0000,0x0000,0x0000,0x0000,  // 2
//     0x0000,0x0000,0x0000,0x0000,0x0c10,0x1c18,0x381c,0x30cc,0x30cc,0x39cc,0x1ffc,0x0f38,0x0000,0x0000,0x0000,0x0000,  // 3
//     0x0000,0x0000,0x0000,0x0000,0x0e00,0x0f00,0x0dc0,0x0ce0,0x0c38,0x3ffc,0x3ffc,0x0c00,0x0000,0x0000,0x0000,0x0000,  // 4
//     0x0000,0x0000,0x0000,0x0000,0x0de0,0x1dfc,0x38dc,0x30cc,0x30cc,0x39cc,0x1f8c,0x0f00,0x0000,0x0000,0x0000,0x0000,  // 5
//     0x0000,0x0000,0x0000,0x0000,0x07e0,0x1ff8,0x399c,0x30cc,0x30cc,0x31cc,0x1f9c,0x0f18,0x0000,0x0000,0x0000,0x0000,  // 6
//     0x0000,0x0000,0x0000,0x0000,0x000c,0x000c,0x3c0c,0x3f8c,0x07ec,0x007c,0x001c,0x000c,0x0000,0x0000,0x0000,0x0000,  // 7
//     0x0000,0x0000,0x0000,0x0000,0x0e70,0x1ff8,0x318c,0x318c,0x318c,0x318c,0x1ff8,0x0e70,0x0000,0x0000,0x0000,0x0000,  // 8
//     0x0000,0x0000,0x0000,0x0000,0x18f0,0x39f8,0x338c,0x330c,0x330c,0x399c,0x1ff8,0x07e0,0x0000,0x0000,0x0000,0x0000,  // 9    
// };

#include "sinclair-m-i-font-16x16.h"

static const uint8_t p0[] = { 0xf8, 0x1f, 0xfc, 0x3f, 0xe, 0x70, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0x6, 0x60, 0xe, 0x70, 0xfc, 0x3f, 0xf8, 0x1f };

const uint8_t numbers[] = {
    0xf8, 0x1f, 0x0, 0x2, 0xf8, 0x1f, 0xf8, 0x1f, 0x0, 0x1f, 0xfe, 0x7f, 0xf8, 0x1f, 0xfe, 0x7f,
    0xf8, 0x1f, 0xf8, 0x1f, 0xfc, 0x3f, 0x0, 0x3, 0xfc, 0x3f, 0xfc, 0x3f, 0x80, 0x1f, 0xfe, 0x7f,
    0xfc, 0x3f, 0xfe, 0x7f, 0xfc, 0x3f, 0xfc, 0x3f, 0x1e, 0x78, 0x80, 0x3, 0xe, 0x78, 0x1e, 0x78,
    0xc0, 0x1d, 0xe, 0x40, 0x1e, 0x78, 0xe, 0x70, 0x1e, 0x78, 0x1e, 0x78, 0xe, 0x70, 0xc0, 0x3, 
    0xe, 0x70, 0xe, 0x70, 0xe0, 0x1c, 0xe, 0x0, 0xe, 0x0, 0x0, 0x70, 0xe, 0x70, 0xe, 0x70, 0xe, 
    0x70, 0xe0, 0x3, 0x0, 0x70, 0x0, 0x70, 0x70, 0x1c, 0xe, 0x0, 0xe, 0x0, 0x0, 0x38, 0xe, 0x70,
    0xe, 0x70, 0xe, 0x70, 0xf0, 0x3, 0x0, 0x70, 0x0, 0x70, 0x38, 0x1c, 0xfe, 0x1f, 0xe, 0x0, 
    0x0, 0x1c, 0x1e, 0x78, 0xe, 0x70, 0xe, 0x70, 0x80, 0x3, 0x0, 0x70, 0x0, 0x3c, 0x1c, 0x1c,
    0xfe, 0x3f, 0xfe, 0x3f, 0x0, 0xe, 0xfc, 0x3f, 0xe, 0x70, 0xe, 0x70, 0x80, 0x3, 0x0, 0x70,
    0x0, 0x1f, 0xe, 0x1c, 0x0, 0x78, 0xfe, 0x7f, 0x0, 0x7, 0xf8, 0x1f, 0x1e, 0x70, 0xe, 0x70,
    0x80, 0x3, 0x0, 0x78, 0x0, 0x1f, 0xfe, 0x7f, 0x0, 0x70, 0x1e, 0x78, 0x80, 0x3, 0x1c, 0x38,
    0xfc, 0x7f, 0xe, 0x70, 0x80, 0x3, 0x0, 0x3c, 0x0, 0x3c, 0xfe, 0x7f, 0x0, 0x70, 0xe, 0x70,
    0xc0, 0x1, 0xe, 0x70, 0xf8, 0x7f, 0xe, 0x70, 0x80, 0x3, 0x0, 0xf, 0x0, 0x78, 0x0, 0x1c, 
    0x0, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 0x0, 0x70, 0xe, 0x70, 0x80, 0x3, 0xc0, 0x3, 
    0x0, 0x70, 0x0, 0x1c, 0x0, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 0x0, 0x70, 0xe, 0x70, 
    0x80, 0x3, 0xf0, 0x0, 0xe, 0x70, 0x0, 0x1c, 0xe, 0x70, 0xe, 0x70, 0xc0, 0x1, 0xe, 0x70, 
    0x0, 0x70, 0x1e, 0x78, 0x80, 0x3, 0x3c, 0x0, 0x1e, 0x78, 0x0, 0x1c, 0x1e, 0x78, 0x1e, 0x78,
    0xc0, 0x1, 0x1e, 0x78, 0x1e, 0x78, 0xfc, 0x3f, 0x80, 0x3, 0xfe, 0x7f, 0xfc, 0x3f, 0x0, 0x1c,
    0xfc, 0x3f, 0xfc, 0x3f, 0xc0, 0x1, 0xfc, 0x3f, 0xfc, 0x3f, 0xf8, 0x1f, 0xe0, 0xf, 0xfe, 0x7f,
    0xf8, 0x1f, 0x0, 0x7e, 0xf8, 0x1f, 0xf8, 0x1f, 0xc0, 0x1, 0xf8, 0x1f, 0xf8, 0x1f };

const uint8_t heartImage[8] =
{
    0B00001110,
    0B00011111,
    0B00111111,
    0B01111110,
    0B01111110,
    0B00111101,
    0B00011001,
    0B00001110
};

void testMem()
{
    for(int y = 0; y < OLED_HEIGHT/8; y++) {
        JOY_OLED_data_start(y);
        // JOY_OLED_send(0xAA);
        // JOY_OLED_send(0x01);
        // JOY_OLED_send(0x55);
        // JOY_OLED_send(0x01);
        // JOY_OLED_send(0xFF);
        // JOY_OLED_send(0x01);
        // JOY_OLED_send(0xFF);
        // JOY_OLED_send(0xFF);
        for(int x = 0; x < 128; x++) {
            JOY_OLED_send(heartImage[x%8]);
        }
        // for(int x = 0; x < 1*64; x++) {
        //     JOY_OLED_send(x);
        // }
        JOY_OLED_end();
    }
}

void showVoltage()
{
    // 8 символов
    char buffer[9] = "U=4.456V";
    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y);
        for(uint8_t c = 0; c < 8; c++) {
            uint8_t digit = buffer[c] - ' ';
            
            for(uint8_t x = 0; x < 16; x++) {
                if(y==1){
                    JOY_OLED_send((font[digit*16 + x] >> 8) & 0xFF);
                } else {
                    JOY_OLED_send(font[digit*16 + x] & 0xFF);
                }
                // JOY_OLED_send((numbers[digit*16 + x] >> 8) & 0xFF);
                // JOY_OLED_send(numbers[digit*16 + x] & 0xFF);
            }
        }
        // for(uint8_t x = 0; x < 128; x++) {
        //     // JOY_OLED_send((MAIN[x+(y*128)]));
        //     JOY_OLED_send(x);
        // }
        JOY_OLED_end();
    }

    // const uint8_t buf2[9]

    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y+2);
        // for(uint8_t c = 0; c < 8; c++) {
        // }
        for(uint8_t x = 0; x < 16; x++) {
            JOY_OLED_send(p0[x*2+y]);
        }

        JOY_OLED_end();
    }


    for(uint8_t y = 0; y < 2; y++) {
        JOY_OLED_data_start(y+4);
        for(uint8_t x = 0; x < 128; x++) {
            JOY_OLED_send(x);
        }

        JOY_OLED_end();
    }

}

int main(void)
{
    init();

    // OLED_clear();

    // OLED_setline(0);
    // OLED_print("Hello, World!");
    // OLED_setline(2);
    // OLED_print("Hello, World!");

    OLED_fill(0x01);

    // showVoltage();
    testMem();

    // uint8_t y,x; 
    // for(y = 0; y < 8; y++) {
    //     JOY_OLED_data_start(y);
    //     for(x = 0; x < 128; x++) {
    //         // JOY_OLED_send((MAIN[x+(y*128)]));
    //         JOY_OLED_send(0xFF);
    //     }
    //     JOY_OLED_end();
    // }

    // DEBUG_println("Start");


    // const uint8_t logo[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00};

    // OLED_draw_bmp(0, 0, 8, 8, logo);

    #define RX_TIMEOUT  500 * DLY_MS_TIME

    uint32_t next_tick = STK->CNT + RX_TIMEOUT;

//   while(((int32_t)(STK->CNT - end)) < 0);

    // uint8_t pattern = 0x01;

    while(1)
    {
        // #if defined(STARTKIT)
        //     PIN_toggle(PIN_LED);
        // #endif
        // DLY_ms(500);

        if(((int32_t)(STK->CNT - next_tick)) > 0) {
            next_tick = STK->CNT + RX_TIMEOUT;

            PIN_toggle(PIN_LED);

            // OLED_fill(pattern++);
        }

    #if 0
        counter++;
        uint32_t duration = last_value / (F_CPU / 1000000);        // Значення у мікросекундах

        DEBUG_printf("Counter: %d  Last value: %d  Duration: %d\n", counter, last_value, duration);
    #endif
    }
}
